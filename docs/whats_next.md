Дальнейшее развитие
===================

Рефакторинг
-----------

### Разделение `Core` и `CoreCompile`

Связующим звеном с инфраструктурой LLVM является объект `CoreCompile`. Поддержка
AOT-компилированных модулей реализована в `Core`. Если разделить `Core` и
`CoreCompile` на две отдельные библиотеки, для релиза можно будет использовать
только библиотеку `Core`, что значительно уменьшит размер сборки.

Для достижения этого предлагаются следующие шаги:

- Создать интерфейс для `CoreCompile`, вероятно с единственной функцией
`newScriptModule`.
- В конструкторе `Core` передавать ссылку (`shared_ptr`) на этот интерфейс. Если
JIT-компиляция не поддерживается, передавать nullptr.
- В реализации `Core` удалить методы для вызова методов `CoreCompile`. Теперь
внешний код создает `CoreCompile` и регистрирует реализации необходимых языков.
- Разделить `Core` и `CoreCompile` на две библиотеки (`as` и `as_compile`),
причем только последняя будет зависеть от LLVM.

### Упрощение интерфейсов `ILanguage` и `ILanguageScript`

На текущий момент пришли к пониманию что достаточно одного интерфейса с
функциями `compile` и `materialize`:
```c++
std::unique_ptr<llvm::Module> compile(const std::string& filename /* ... */) const;
void materialize(/* jit, lib, etc ... */) const;
```

Многие функции в текущей реализации были попыткой вынести общий код во
внутренние классы скриптовой системы. Однако, как показала практика, для
различных языков требуются разные точки интеграции. Более правильный подход -
вынести общий код в библиотеку, чтобы различные реализации могли его
использовать.

Также интерфейсы создавались для хранения функционала, необходимого для связи с
runtime конкретного скриптового языка. Однако такой подход не позволяет
реализовать AOT-компиляцию, поэтому был выделен отдельный интерфейс
`ILanguageRuntime`.

Необходимо выполнить следующие шаги:

- Убедиться, что все реализации перешли на использование `ILanguageRuntime`.
- `ScriptModuleCompile` будет вызывать функции `compile` и `materialize`.

### Единый способ получения интерфейса для реализации

В текущей реализации интерфейс для скриптового модуля можно получить двумя
способами:

- Из самого файла скрипта (во время AOT-компиляции или перезагрузки).
- Из шаблонов (во время первой JIT-компиляции).

Предлагается прекратить использование интерфейса из шаблонов для реализации
скриптовых модулей. Вместо этого, использовать его только для проверки типов,
если он уже существует.

Таким образом, можно упростить логику и улучшить типовую безопасность кода.

### Использование внешних объектов

В настоящее время поддержка внешних объектов реализована только для языка Lua.
Для поддержки внешних объектов необходимо зарегистрировать интерфейс и указатель
на объект на уровне каждой реализации языка. Это не поддерживается в режиме
AOT-компиляции, так как в этом режиме отсутствует реализация языка.

Предлагается следующий подход:

- Каждый скрипт может указать, что он ожидает внешний объект с заданным именем,
реализующий заданный интерфейс.
- На основе такой декларации можно генерировать IR-код для вызова методов
внешнего объекта.
- Экземпляры внешних объектов можно получать в функции `init` модуля, что
обеспечит позднее связывание.

Этот же механизм можно потенциально использовать для runtime-объектов языков.


Развитие функционала
--------------------

### Горячая перезагрузка на разных платформах

Горячая перезагрузка файлов должна стать частью функционала `CoreCompile`. Этот
функционал применим только в режиме JIT-компиляции, и `CoreCompile` работает
непосредственно с файлами.

Учитывая, что реализация слежения за изменениями в файловой системе зависит от
платформы, это следует реализовать в виде стратегий. Корректная стратегия будет
выбрана во время компиляции или выполнения.

### Поддержать загрузку нескольких файлов для одного скриптового модуля

Один скриптовый модуль, предоставляющий функционал в проект, может зависеть от
других "внутренних" скриптовых модулей. При загрузке "главного" модуля
необходимо сообщать `CoreCompile` имена всех загруженных модулей, чтобы при
изменении этих файлов происходила перезагрузка.

В дальнейшем следует перенести логику работы с файлами в `CoreCompile`, а
реализация поддержки языков будет работать исключительно с содержимым.

### Проверка типов во время JIT компиляции и перезагрузки

Во время JIT-компиляции (как при первой компиляции, так и при перезагрузке) у
нас есть требуемый интерфейс модуля. С другой стороны, у нас есть интерфейс,
реализуемый модулем. Эти интерфейсы должны совпадать, и их можно проверить на
соответствие.

### Использование модулей как внешних объектов

Модуль может зарегистрировать себя как внешний объект с заданным именем, и
дальше любые другие скрипты, на произвольных языках, могут использовать логику
этого модуля. Скорее всего это будет основной для поддержки ECS архитектуры.