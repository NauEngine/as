Описание Архитектуры Agnostic Script
====================================

tl;dr;
------
Две основные идеи скриптовой системы Agnostic Script - это представление
скриптовых модулей как обычных объектов C++, и использование инфраструктуры
[LLVM](https://llvm.org/) для поддержки различных языков программирования для
скриптов.

Представление скриптовых модулей в виде объектов C++ позволяет эффективно
интегрировать их с игровым движком и управлять их жизненным циклом. Этот метод
также обеспечивает производительность, сопоставимую с нативной реализацией.

Использование инфраструктуры LLVM решает задачи JIT-компиляции скриптов во время
разработки и AOT-компиляции для релизных версий.

```c++
#include "as/core/core.h"
#include "as/languages/lua/lua_language.h"

// объявление интерфейса, который должен быть реализован в скриптовых модулях
DEFINE_SCRIPT_INTERFACE(TestScript,
    virtual int add(int a, int b) = 0;
)

int main()
{
    // создаем скриптовую систему, указываем корневую директорию со скриптами
    auto script_core = std::make_shared<as::Core>("../sandbox/scripts");

    // создаем и регистрируем поддержку языка Lua в скриптовой систему
    auto language = std::make_shared<as::LuaLanguage>();
    script_core->registerLanguage("lua", std::move(language));

    // создаем модуль на основе скрипта из файла test.lua
    auto module = script_core->newScriptModule<TestScript>("test.lua");

    // создаем экземпляр объекта на основе модуля
    auto instane = module->newInstance();

    // вызываем функцию у объекта
    assert(instane->add(10, 20) == 30);

    // You're breathtaking (c) Keanu Reeves
    return 0;
}
```


Описание работы
---------------

### Основные концепции

#### Скриптовые модули

В скриптовой системе основной единицей компиляции является модуль. Каждый модуль
должен реализовывать один и только один интерфейс. Для каждого модуля, в
зависимости от реализации, автоматически генерируется список доступных методов.
Затем, с использованием фреймворка LLVM, создается байткод для этих методов,
формируя виртуальную таблицу методов (VMT) для данного модуля.

#### Режимы работы

Скриптовая система поддерживает два режима работы:
- **JIT-компиляция**: компиляция скриптов во время выполнения.
- **AOT-компиляция**: компиляция скриптов на этапе сборки проекта.

Режим JIT-компиляции используется преимущественно на стадии разработки,
предоставляя возможность динамической перезагрузки скриптов. Режим
AOT-компиляции преобразует скрипты в байткод на этапе сборки, что делает его
подходящим для релизных версий приложений. Возможна одновременная работа в обоих
режимах, что позволяет, например, поддерживать пользовательские расширения.

#### Функция `init`

Функция `init` служит точкой входа для модуля. При её вызове происходит
регистрация виртуальной таблицы методов модуля в скриптовой системе, связывание
с runtime-библиотекой, а также выполнение любой необходимой логики инициализации
модуля.

#### Runtime-библиотека

Для реализации некоторых языков может потребоваться дополнительная логика,
например, управление памятью. В таких случаях используется runtime-библиотека.
Эта библиотека регистрируется в скриптовой системе и становится доступной в коде
модуля.

### Логика работы

В общем случае процесс работы одинаков для обоих режимов: JIT и AOT. Он включает
два основных шага: компиляцию модуля в промежуточное представление (IR) и
последующую материализацию.

### Компиляция

Результатом компиляции является функция `init`, которая связывает скриптовый
модуль с системой. Компиляция проходит через несколько стадий:
- Определение интерфейса, который реализует модуль.
- Генерация LLVM-модуля.
- Создание функции `init`.

#### Определение интерфейса

Интерфейс, реализуемый модулем, указывается в коде с помощью специальных
конструкций языка, например, через комментарий. Имя файла с декларацией
интерфейса (`.h`) подключается к игровому коду, что обеспечивает его интеграцию.

#### Генерация LLVM-модуля

Для каждой функции модуля генерируется IR-код. Кроме того, создается IR-код с
декларацией глобальной переменной, содержащей виртуальную таблицу методов
интерфейса. Также на этом этапе генерируется весь необходимый код для работы
модуля, включая глобальные переменные, связи с runtime-библиотекой, функции
инициализации и другие элементы.

#### Генерация функции `init`

Функция `init` связывает код модуля со скриптовой системой: регистрирует
виртуальную таблицу методов, получает доступ к runtime-библиотекам и вызывает
функции инициализации.

- **Для JIT-режима**: функция объявляется глобальной, чтобы её можно было
вызвать из скриптовой системы.
- **Для AOT-режима**: функция `init` объявляется внутренней, и дополнительно
создается функция `cotr`, которая вызывается при загрузке модуля и регистрирует
`init`-функцию. Это позволяет обеспечить позднее связывание модулей с
runtime-библиотеками. Функция `init` модуля вызывается при первом создании
объекта этого модуля.

### Материализация

Материализация применяется только в JIT-режиме. В этом процессе с помощью
средств LLVM создается байткод для текущей платформы выполнения и вызывается
функция `init`.

Для AOT-режима вместо материализации выполняется загрузка предварительно
сгенерированного модуля.


Детали реализации
-----------------

Собственно у скриптовой системы две части `Core` и `CoreCompile`

### `Core`

Система отвечает за представление скриптовых модулей как объектов C++. `Core`
содержит экземпляр `CoreCompile` и методы для вызова его функций.

Система создает фабрики объектов в соответствии с указанным именем файла. Каждая
фабрика хранит указатель на таблицу методов (virtual table), описанных в
данном модуле и реализующих указанный интерфейс. Фабрика затем создает
экземпляры объектов с данной таблицей методов.

Для регистрации фабрики с каждым скриптовым модулем связана `init`-функция,
которая регистрирует таблицу и позволяет связать модуль с runtime-библиотекой,
необходимой для поддержки конкретного языка.

Есть два способа получить функцию `init`-функцию:
- Во время выполнения через `CoreCompile`, когда указанный модуль компилируется
и материализуется с помощью инфраструктуры LLVM.
- Во время компиляции, когда каждый модуль скомпилирован в байт-код. В этом
случае генерируется секция статической инициализации, которая регистрирует
`init`-функцию модуля для конкретного имени файла.

#### Конструктор `Core`
```c++
explicit Core(const std::string& base_path = "");
```

Создает новый экземпляр `Core`.
- `base_path` - корневая директория со скриптами.

Так как имя файла используется для идентификации модуля, оно должно совпадать
как для JIT-компиляции, так и для AOT-компиляции. Это позволяет согласовать
директории со скриптами как во время выполнения JIT-компиляции, так и при
AOT-компиляции.

#### `newScriptModule`
```c++
template<typename Interface>
std::shared_ptr<ScriptModule<Interface>> newScriptModule(const std::string& filename,
    const std::string& language_name = "")
```

Создание фабрики для объектов скриптового модуля
- **`filename`** — имя файла со скриптом.
- **`language_name`** — язык для данного модуля. Если не указан, язык
определяется по расширению файла.
- **Возвращаемое значение** — указатель на фабрику или `nullptr`, если для
данного имени файла не может быть создана фабрика. Фабриками управляет `Core`.

Логика создания фабрики
1. **Кеширование фабрик**: Все созданные фабрики кешируются. Первым делом ищется
уже готовая фабрика для данного имени файла.
2. **Поиск в кеше**: Если в кеше фабрики нет, ищется `init`-функция для данного
имени файла, которая могла быть зарегистрирована от скомпилированного модуля.
3. **Компиляция модуля**: Если `init`-функция не была зарегистрирована,
вызывается компиляция данного модуля посредством `CoreCompile`.
4. **Вызов `init`-функции**: После получения `init`-функции она вызывается. В
момент вызова регистрируется таблица методов для данного модуля, после чего
создается и кешируется фабрика.

#### `registerLanguage`, `registerInstance`
```c++
template<typename Interface>
void registerLanguage(const std::string& language_name, const std::shared_ptr<ILanguage>& language)

void registerInstance(Interface* instance, const std::string& instance_name);
```
Методы для вызова соотв. методов внутреннего `CoreCompile`

#### `registerRuntime`
```c++
void registerRuntime(std::shared_ptr<ILanguageRuntime> runtime);
```

Регистрация runtime библиотеки для поддержки языка.
- **`runtime`** — собственно экземпляр библиотеки.

#### `reload`

```c++
void reload(const std::string& filename);
```

Перезагрузка указанного модуля
- **`filename`** - имя файла модуля

#### `registerVTable`, `requireRuntime`
```c++
void registerVTable(const char* name, ScriptModuleRuntime::FunctionPtr* vtable, int vtable_size);

const void* requireRuntime(const char* name);
```

Внутренние функции для вызова в `init`-функциях модулей. `registerVTable` -
регистрирует (или обновляет) таблицу виртуальных методов модуля.
`requireRuntime` - получает runtime библиотеку по имени.

Для вызова функций используются обертки в виде `extern "C"`функций, таким
образом их проще вызывать из модулей:

```c++
extern "C" void __asRegisterVTable(as::Core* core, const char* name, as::ScriptModuleRuntime::FunctionPtr* vtable, int vtable_size)
{
    core->registerVTable(name, vtable, vtable_size);
}

extern "C" const void* __asRequireRuntime(as::Core* core, const char* name)
{
    return core->requireRuntime(name);
}
```

### `ScriptModule<Interface>`

#### `newInstance`

### `CoreCompile`

#### `registerLanguage`

#### `registerInstance`

#### `newScriptModule`

### `ScriptModuleCompile`

#### `dump`

#### `materialize`