Описание Архитектуры Agnostic Script
====================================

tl;dr;
------
Две основные идеи скриптовой системы Agnostic Script - это представление
скриптовых модулей как обычных объектов C++, и использование инфраструктуры
[LLVM](https://llvm.org/) для поддержки различных языков программирования для
скриптов.

Представление скриптовых модулей в виде объектов C++ позволяет эффективно
интегрировать их с игровым движком и управлять их жизненным циклом. Этот метод
также обеспечивает производительность, сопоставимую с нативной реализацией.

Использование инфраструктуры LLVM решает задачи JIT-компиляции скриптов во время
разработки и AOT-компиляции для релизных версий.

```c++
#include "as/core/core.h"
#include "as/languages/lua/lua_language.h"

// объявление интерфейса, который должен быть реализован в скриптовых модулях
DEFINE_SCRIPT_INTERFACE(TestScript,
    virtual int add(int a, int b) = 0;
)

int main()
{
    // создаем скриптовую систему, указываем корневую директорию со скриптами
    auto script_core = std::make_shared<as::Core>("../sandbox/scripts");

    // создаем и регистрируем поддержку языка Lua в скриптовой систему
    auto language = std::make_shared<as::LuaLanguage>();
    script_core->registerLanguage("lua", std::move(language));

    // создаем модуль на основе скрипта из файла test.lua
    auto module = script_core->newScriptModule<TestScript>("test.lua");

    // создаем экземпляр объекта на основе модуля
    auto instane = module->newInstance();

    // вызываем функцию у объекта
    assert(instane->add(10, 20) == 30);

    // You're breathtaking (c) Keanu Reeves
    return 0;
}
```


Логика работы
-------------

### Базовые понятия

#### Режимы работы

Скриптовая система имеет два режима работы:
- **JIT-компиляция**: компиляция скриптов во время выполнения.
- **AOT-компиляция**: компиляция скриптов во время сборки проекта.

JIT-компиляция используется во время разработки и поддерживает перезагрузку
скриптов. При AOT-компиляции скрипты уже преобразованы в байт-код, и этот режим
предназначен для использования в релизных версиях приложений. Возможно
одновременное использование обоих режимов, например, для поддержки
пользовательских расширений.

#### Скриптовые модули



#### Таблица методов

![Виртуальная таблица методов!](./architecture-vtable.svg)

В памяти для обычные объектов C++ в самом начале идет указатель на [вирутальную
таблицу методов](https://en.wikipedia.org/wiki/Virtual_method_table). 

### Сценарии использования

#### Загрузка модуля

#### Перезагрузка модуля

#### Использование внешнего объекта


Части скриптовой системы
------------------------

Собственно у скриптовой системы две части `Core` и `CoreCompile`

### `Core`
Отвечает за представление скриптовых модулей как С++ объектов. Так же внутри
себя содержит экземпляр `CoreCompile` и методы для вызова методов `CoreCompile`.

Собственно `Core` создает фабрики объектов в соотв. по указанному имени файла.
Каждая фабрика хранит указатель на таблицу методов (собственно virtual table),
описанных в данном модуле и реализующие указанные интерфейс. Дальше фабрика
создает экземпляры объектов, с данной таблицей методов.

Для регистрации фабрики, с каждым скриптовым модулем связана `init`-функция,
которая регистрирует таблицу, а также позволяет связать модуль с runtime
библиотекой, необходимой для поддержки конкретного языка.

Есть два способа получить `init`-функцию:
- Во время выполнения, посредством `CoreCompile`, когда указанный модуль
компилируется и материализуется при помощи инфраструктры LLVM
- Во время компиляции, когда каждый модуль скомпилирован в байт код,
генерируется секция статической инициализации, которая собственно и регистрирует
`init`-функцию модуля

#### Конструктор `Core`
```c++
explicit Core(const std::string& base_path = "");
```

#### `newScriptModule`
```c++
template<typename Interface>
std::shared_ptr<ScriptModule<Interface>> newScriptModule(const std::string& filename,
    const std::string& language_name = "")
```

Создание фабрики для объектов скриптового модуля.
- `filename` - имя файла со скриптом
- `language_name` - язык для данного модуля. Если не указан, используемый язык
определяется по расширению файла
- **Возвращаемое значение** - Указатель на фабрику, или `nullptr` если для данного имени файла не
может быть создано фабрики. Фабриками владеет `Core`

Логика создания фабрики слелующая. 
- Все созданные фабрики кешируются, поэтому первым делом ищется уже готовая
фабрика, для данного имени файла
- Если в кеше фабрики нет, ищется `init`-функция для данного имени файла,
которая могла быть зарегистрированна от скомпилированного модуля
- Если `init`-функция не была зарегистрированна - вызывается компиляция
данного модуля посредством `CoreCompile`
- После того, как `init`-функция была получена, она вызывается, в момент вызова
регистрируется таблица методов для данного модуля, создается и кешируется
фабрика

#### `registerLanguage`, `registerInstance`
```c++
template<typename Interface>
void registerLanguage(const std::string& language_name, const std::shared_ptr<ILanguage>& language)

void registerInstance(Interface* instance, const std::string& instance_name);
```
Методы для вызова соотв. методов внутреннего `CoreCompile`

### `CoreCompile`
