Описание Архитектуры Agnostic Script
====================================

tl;dr;
------
Две основные идем скриптовой системы Agnostic Script - это представление
скриптовых модулей как обычных объектов C++, и использование инфраструктуры
[LLVM](https://llvm.org/) для поддержки различных языков программирования для
скриптов.

Представления скриптовых модулей как объектов С++ решает вопросы интеграции
с игровым движком и управлением времени жизни. Так же такой способ обеспечивает
быстродействие на уровне нативной реализации.

Благодаря использованию инфраструктуры LLVM решаются вопросы JIT компиляции
скриптов (во время разработки) и AOT компиляции сприптов (для релиза).

```c++
#include "as/core/core.h"
#include "as/languages/lua/lua_language.h"

// объявление интерфейса, который должен быть реализован в скриптовых можулях
DEFINE_SCRIPT_INTERFACE(TestScript,
    virtual int add(int a, int b) = 0;
)

int main()
{
    // создаем скриптовую систему, указываем корневую директорию со скриптами
    auto script_core = std::make_shared<as::Core>("../sandbox/scripts");

    // создаем и регистрируем поддержку языка Lua в скриптовой систему
    auto language = std::make_shared<as::LuaLanguage>();
    script_core->registerLanguage("lua", std::move(language));

    // создаем модуль на основе скрипта из файла test.lua
    auto module = script_core->newScriptModule<TestScript>("test.lua");

    // создаем экземпляр объекта на основе модуля
    auto instane = module->newInstance();

    // вызываем функцию у объекта
    assert(instane->add(10, 20) == 30);

    // You're breathtaking (c) Keanu Reeves
    return 0;
}
```


Логика работы
-------------

### Базовые понятия

#### Режимы работы

У скриптовой системы есть два "режима" работы:
- **JIT компиляция**: компиляция скриптов во время выполения
- **AOT компиляция**: компиляция скриптов во время сборки проекта

JIT компиляция используется во время разработки, поддерживает перезагрузку
скриптов. При AOT компиляции скрипты уже преобразованы в байт код, и этот режим
подразумевается использовать в релизе приложений. Однако возможно одновременное
использование обоих режимов (например для поддержки пользовательских
расширений).

#### Таблица функций

(./architecture-vtable.svg "виртуальная таблица функций")

#### Скриптовые модули

### Сценарии использования

#### Загрузка модуля

#### Перезагрузка модуля

#### Использование внешнего объекта


Части скриптовой системы
------------------------

Собственно у скриптовой системы две части `Core` и `CoreCompile`

### `Core`
Отвечает за представление скриптовых модулей как С++ объектов. Так же внутри
себя содержит экземпляр `CoreCompile` и методы для вызова методов `CoreCompile`.

Собственно `Core` создает фабрики объектов в соотв. по указанному имени файла.
Каждая фабрика хранит указатель на таблицу функций (собственно virtual table),
описанных в данном модуле и реализующие указанные интерфейс. Дальше фабрика
создает экземпляры объектов, с данной таблицей функций.

Для регистрации фабрики, с каждым скриптовым модулем связана `init`-функция,
которая регистрирует таблицу, а также позволяет связать модуль с runtime
библиотекой, необходимой для поддержки конкретного языка.

Есть два способа получить `init`-функцию:
- Во время выполнения, посредством `CoreCompile`, когда указанный модуль
компилируется и материализуется при помощи инфраструктры LLVM
- Во время компиляции, когда каждый модуль скомпилирован в байт код,
генерируется секция статической инициализации, которая собственно и регистрирует
`init`-функцию модуля

#### Конструктор `Core`
```c++
explicit Core(const std::string& base_path = "");
```

#### `newScriptModule`
```c++
template<typename Interface>
std::shared_ptr<ScriptModule<Interface>> newScriptModule(const std::string& filename,
    const std::string& language_name = "")
```

Создание фабрики для объектов скриптового модуля.
- `filename` - имя файла со скриптом
- `language_name` - язык для данного модуля. Если не указан, используемый язык
определяется по расширению файла
- **Возвращаемое значение** - Указатель на фабрику, или `nullptr` если для данного имени файла не
может быть создано фабрики. Фабриками владеет `Core`

Логика создания фабрики слелующая. 
- Все созданные фабрики кешируются, поэтому первым делом ищется уже готовая
фабрика, для данного имени файла
- Если в кеше фабрики нет, ищется `init`-функция для данного имени файла,
которая могла быть зарегистрированна от скомпилированного модуля
- Если `init`-функция не была зарегистрированна - вызывается компиляция
данного модуля посредством `CoreCompile`
- После того, как `init`-функция была получена, она вызывается, в момент вызова
регистрируется таблица функций для данного модуля, создается и кешируется
фабрика

#### `registerInstance`, `registerRuntime`
```c++
template<typename Interface>
void registerInstance(Interface* instance, const std::string& instance_name);

void registerRuntime(std::shared_ptr<ILanguageRuntime> runtime);
```
Методы для вызова соотв. методов внутреннего `CoreCompile`

### `CoreCompile`


Реализация поддержки нового скриптового языка
---------------------------------------------


Дальнешее развитие
------------------



