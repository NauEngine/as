Описание Архитектуры Agnostic Script
====================================

tl;dr;
------
Две основные идеи скриптовой системы Agnostic Script - это представление
скриптовых модулей как обычных объектов C++, и использование инфраструктуры
[LLVM](https://llvm.org/) для поддержки различных языков программирования для
скриптов.

Представление скриптовых модулей в виде объектов C++ позволяет эффективно
интегрировать их с игровым движком и управлять их жизненным циклом. Этот метод
также обеспечивает производительность, сопоставимую с нативной реализацией.

Использование инфраструктуры LLVM решает задачи JIT-компиляции скриптов во время
разработки и AOT-компиляции для релизных версий.

```c++
#include "as/core/core.h"
#include "as/languages/lua/lua_language.h"

// объявление интерфейса, который должен быть реализован в скриптовых модулях
DEFINE_SCRIPT_INTERFACE(TestScript,
    virtual int add(int a, int b) = 0;
)

int main()
{
    // создаем скриптовую систему, указываем корневую директорию со скриптами
    auto script_core = std::make_shared<as::Core>("../sandbox/scripts");

    // создаем и регистрируем поддержку языка Lua в скриптовой систему
    auto language = std::make_shared<as::LuaLanguage>();
    script_core->registerLanguage("lua", std::move(language));

    // создаем модуль на основе скрипта из файла test.lua
    auto module = script_core->newScriptModule<TestScript>("test.lua");

    // создаем экземпляр объекта на основе модуля
    auto instane = module->newInstance();

    // вызываем функцию у объекта
    assert(instane->add(10, 20) == 30);

    // You're breathtaking (c) Keanu Reeves
    return 0;
}
```


Логика работы
-------------

### Базовые понятия

#### Режимы работы

Скриптовая система имеет два режима работы:
- **JIT-компиляция**: компиляция скриптов во время выполнения.
- **AOT-компиляция**: компиляция скриптов во время сборки проекта.

JIT-компиляция используется во время разработки и поддерживает перезагрузку
скриптов. При AOT-компиляции скрипты уже преобразованы в байт-код, и этот режим
предназначен для использования в релизных версиях приложений. Возможно
одновременное использование обоих режимов, например, для поддержки
пользовательских расширений.

#### Скриптовые модули



#### Таблица методов

![Виртуальная таблица методов!](./architecture-vtable.svg)

В памяти для обычные объектов C++ в самом начале идет указатель на [вирутальную
таблицу методов](https://en.wikipedia.org/wiki/Virtual_method_table). 

### Сценарии использования

#### Загрузка модуля

#### Перезагрузка модуля

#### Использование внешнего объекта


Части скриптовой системы
------------------------

Собственно у скриптовой системы две части `Core` и `CoreCompile`

### `Core`

Система отвечает за представление скриптовых модулей как объектов C++. `Core`
содержит экземпляр `CoreCompile` и методы для вызова его функций.

Система создает фабрики объектов в соответствии с указанным именем файла. Каждая
фабрика хранит указатель на таблицу методов (virtual table), описанных в
данном модуле и реализующих указанный интерфейс. Фабрика затем создает
экземпляры объектов с данной таблицей методов.

Для регистрации фабрики с каждым скриптовым модулем связана `init`-функция,
которая регистрирует таблицу и позволяет связать модуль с runtime-библиотекой,
необходимой для поддержки конкретного языка.

Есть два способа получить функцию `init`-функцию:
- Во время выполнения через `CoreCompile`, когда указанный модуль компилируется
и материализуется с помощью инфраструктуры LLVM.
- Во время компиляции, когда каждый модуль скомпилирован в байт-код. В этом
случае генерируется секция статической инициализации, которая регистрирует
`init`-функцию модуля для конкретного имени файла.

#### Конструктор `Core`
```c++
explicit Core(const std::string& base_path = "");
```

Создает новый экземпляр `Core`.
- `base_path` - корневая директория со скриптами.

Так как имя файла используется для идентификации модуля, оно должно совпадать
как для JIT-компиляции, так и для AOT-компиляции. Это позволяет согласовать
директории со скриптами как во время выполнения JIT-компиляции, так и при
AOT-компиляции.

#### `newScriptModule`
```c++
template<typename Interface>
std::shared_ptr<ScriptModule<Interface>> newScriptModule(const std::string& filename,
    const std::string& language_name = "")
```

Создание фабрики для объектов скриптового модуля
- **`filename`** — имя файла со скриптом.
- **`language_name`** — язык для данного модуля. Если не указан, язык
определяется по расширению файла.
- **Возвращаемое значение** — указатель на фабрику или `nullptr`, если для
данного имени файла не может быть создана фабрика. Фабриками управляет `Core`.

Логика создания фабрики
1. **Кеширование фабрик**: Все созданные фабрики кешируются. Первым делом ищется
уже готовая фабрика для данного имени файла.
2. **Поиск в кеше**: Если в кеше фабрики нет, ищется `init`-функция для данного
имени файла, которая могла быть зарегистрирована от скомпилированного модуля.
3. **Компиляция модуля**: Если `init`-функция не была зарегистрирована,
вызывается компиляция данного модуля посредством `CoreCompile`.
4. **Вызов `init`-функции**: После получения `init`-функции она вызывается. В
момент вызова регистрируется таблица методов для данного модуля, после чего
создается и кешируется фабрика.

#### `registerLanguage`, `registerInstance`
```c++
template<typename Interface>
void registerLanguage(const std::string& language_name, const std::shared_ptr<ILanguage>& language)

void registerInstance(Interface* instance, const std::string& instance_name);
```
Методы для вызова соотв. методов внутреннего `CoreCompile`

#### `registerRuntime`
```c++
void registerRuntime(std::shared_ptr<ILanguageRuntime> runtime);
```

Регистрация runtime библиотеки для поддержки языка.
- **`runtime`** — собственно экземпляр библиотеки.

#### `reload`

```c++
void reload(const std::string& filename);
```

Перезагрузка указанного модуля
- **`filename`** - имя файла модуля

#### `registerVTable`, `requireRuntime`
```c++
void registerVTable(const char* name, ScriptModuleRuntime::FunctionPtr* vtable, int vtable_size);

const void* requireRuntime(const char* name);
```

Внутренние функции для вызова в `init`-функциях модулей. `registerVTable` -
регистрирует (или обновляет) таблицу виртуальных методов модуля.
`requireRuntime` - получает runtime библиотеку по имени.

Для вызова функций используются обертки в виде `extern "C"`функций, таким
образом их проще вызывать из модулей:

```c++
extern "C" void __asRegisterVTable(as::Core* core, const char* name, as::ScriptModuleRuntime::FunctionPtr* vtable, int vtable_size)
{
    core->registerVTable(name, vtable, vtable_size);
}

extern "C" const void* __asRequireRuntime(as::Core* core, const char* name)
{
    return core->requireRuntime(name);
}
```

### `CoreCompile`
