Описание Архитектуры Agnostic Script
====================================

tl;dr;
------
Две основные идеи скриптовой системы Agnostic Script - это представление
скриптовых модулей как обычных объектов C++, и использование инфраструктуры
[LLVM](https://llvm.org/) для поддержки различных языков программирования для
скриптов.

Представление скриптовых модулей в виде объектов C++ позволяет эффективно
интегрировать их с игровым движком и управлять их жизненным циклом. Этот метод
также обеспечивает производительность, сопоставимую с нативной реализацией.

Использование инфраструктуры LLVM решает задачи JIT-компиляции скриптов во время
разработки и AOT-компиляции для релизных версий.

```c++
#include "as/core/core.h"
#include "as/languages/lua/lua_language.h"

// объявление интерфейса, который должен быть реализован в скриптовых модулях
DEFINE_SCRIPT_INTERFACE(TestScript,
    virtual int add(int a, int b) = 0;
)

int main()
{
    // создаем скриптовую систему, указываем корневую директорию со скриптами
    auto script_core = std::make_shared<as::Core>("../sandbox/scripts");

    // создаем и регистрируем поддержку языка Lua в скриптовой систему
    auto language = std::make_shared<as::LuaLanguage>();
    script_core->registerLanguage("lua", std::move(language));

    // создаем модуль на основе скрипта из файла test.lua
    auto module = script_core->newScriptModule<TestScript>("test.lua");

    // создаем экземпляр объекта на основе модуля
    auto instane = module->newInstance();

    // вызываем функцию у объекта
    assert(instane->add(10, 20) == 30);

    // You're breathtaking (c) Keanu Reeves
    return 0;
}
```


Логика работы
-------------

### Базовые понятия

#### Режимы работы

Скриптовая система имеет два режима работы:
- **JIT-компиляция**: компиляция скриптов во время выполнения.
- **AOT-компиляция**: компиляция скриптов во время сборки проекта.

JIT-компиляция используется во время разработки и поддерживает перезагрузку
скриптов. При AOT-компиляции скрипты уже преобразованы в байт-код, и этот режим
предназначен для использования в релизных версиях приложений. Возможно
одновременное использование обоих режимов, например, для поддержки
пользовательских расширений.

#### Таблица функций

![Виртуальная таблица функций!](./architecture-vtable.svg)

#### Скриптовые модули

### Сценарии использования

#### Загрузка модуля

#### Перезагрузка модуля

#### Использование внешнего объекта


Части скриптовой системы
------------------------

Собственно у скриптовой системы две части `Core` и `CoreCompile`

### `Core`
Отвечает за представление скриптовых модулей как С++ объектов. Так же внутри
себя содержит экземпляр `CoreCompile` и методы для вызова методов `CoreCompile`.

Собственно `Core` создает фабрики объектов в соотв. по указанному имени файла.
Каждая фабрика хранит указатель на таблицу функций (собственно virtual table),
описанных в данном модуле и реализующие указанные интерфейс. Дальше фабрика
создает экземпляры объектов, с данной таблицей функций.

Для регистрации фабрики, с каждым скриптовым модулем связана `init`-функция,
которая регистрирует таблицу, а также позволяет связать модуль с runtime
библиотекой, необходимой для поддержки конкретного языка.

Есть два способа получить `init`-функцию:
- Во время выполнения, посредством `CoreCompile`, когда указанный модуль
компилируется и материализуется при помощи инфраструктры LLVM
- Во время компиляции, когда каждый модуль скомпилирован в байт код,
генерируется секция статической инициализации, которая собственно и регистрирует
`init`-функцию модуля

#### Конструктор `Core`
```c++
explicit Core(const std::string& base_path = "");
```

#### `newScriptModule`
```c++
template<typename Interface>
std::shared_ptr<ScriptModule<Interface>> newScriptModule(const std::string& filename,
    const std::string& language_name = "")
```

Создание фабрики для объектов скриптового модуля.
- `filename` - имя файла со скриптом
- `language_name` - язык для данного модуля. Если не указан, используемый язык
определяется по расширению файла
- **Возвращаемое значение** - Указатель на фабрику, или `nullptr` если для данного имени файла не
может быть создано фабрики. Фабриками владеет `Core`

Логика создания фабрики слелующая. 
- Все созданные фабрики кешируются, поэтому первым делом ищется уже готовая
фабрика, для данного имени файла
- Если в кеше фабрики нет, ищется `init`-функция для данного имени файла,
которая могла быть зарегистрированна от скомпилированного модуля
- Если `init`-функция не была зарегистрированна - вызывается компиляция
данного модуля посредством `CoreCompile`
- После того, как `init`-функция была получена, она вызывается, в момент вызова
регистрируется таблица функций для данного модуля, создается и кешируется
фабрика

#### `registerLanguage`, `registerInstance`
```c++
template<typename Interface>
void registerLanguage(const std::string& language_name, const std::shared_ptr<ILanguage>& language)

void registerInstance(Interface* instance, const std::string& instance_name);
```
Методы для вызова соотв. методов внутреннего `CoreCompile`

### `CoreCompile`


Реализация поддержки нового скриптового языка
---------------------------------------------


Дальнешее развитие
------------------

### Рефакторинг

#### Разделение `Core` и `CoreCompile`

Связующим звеном с инфраструктурой LLVM является объект `CoreCompile`. Поддержка
AOT-компилированных модулей реализована в `Core`. Если разделить `Core` и
`CoreCompile` на две отдельные библиотеки, для релиза можно будет использовать
только библиотеку `Core`, что значительно уменьшит размер сборки.

Для достижения этого предлагаются следующие шаги:

- Создать интерфейс для `CoreCompile`, вероятно с единственной функцией
`newScriptModule`.
- В конструкторе `Core` передавать ссылку (`shared_ptr`) на этот интерфейс. Если
JIT-компиляция не поддерживается, передавать nullptr.
- В реализации `Core` удалить методы для вызова функций `CoreCompile`. Теперь
внешний код создает `CoreCompile` и регистрирует реализации необходимых языков.
- Разделить `Core` и `CoreCompile` на две библиотеки (`as` и `as_compile`),
причем только последняя будет зависеть от LLVM.

#### Упрощение интерфейсов `ILanguage` и `ILanguageScript`

На текущий момент пришли к пониманию что достаточно одного интерфейса с
функциями `compile` и `materialize`:
```c++
std::unique_ptr<llvm::Module> compile(const std::string& filename /* ... */) const;
void materialize(/* jit, lib, etc ... */) const;
```

Многие функции в текущей реализации были попыткой вынести общий код во
внутренние классы скриптовой системы. Однако, как показала практика, для
различных языков требуются разные точки интеграции. Более правильный подход -
вынести общий код в библиотеку, чтобы различные реализации могли его
использовать.

Также интерфейсы создавались для хранения функционала, необходимого для связи с
runtime конкретного скриптового языка. Однако такой подход не позволяет
реализовать AOT-компиляцию, поэтому был выделен отдельный интерфейс
`ILanguageRuntime`.

Необходимо выполнить следующие шаги:

- Убедиться, что все реализации перешли на использование `ILanguageRuntime`.
- `ScriptModuleCompile` будет вызывать функции `compile` и `materialize`.

#### Единый способ получения интерфейса для реализации

В текущей реализации интерфейс для скриптового модуля можно получить двумя
способами:

- Из самого файла скрипта (во время AOT-компиляции или перезагрузки).
- Из шаблонов (во время первой JIT-компиляции).

Предлагается прекратить использование интерфейса из шаблонов для реализации
скриптовых модулей. Вместо этого, использовать его только для проверки типов,
если он уже существует.

Таким образом, можно упростить процесс и улучшить типовую безопасность кода.

### Развитие функционала

#### Горячая перезагрузка на разных платформах

Горячая перезагрузка файлов должна стать частью функционала `CoreCompile`. Этот
функционал применим только в режиме JIT-компиляции, и `CoreCompile` работает
непосредственно с файлами.

Учитывая, что реализация слежения за изменениями в файловой системе зависит от
платформы, это следует реализовать в виде стратегий. Корректная стратегия будет
выбрана во время компиляции или выполнения.

#### Поддержать загрузку нескольких файлов для одного скриптового модуля

Один скриптовый модуль, предоставляющий функционал в проект, может зависеть от
других "внутренних" скриптовых модулей. При загрузке "главного" модуля
необходимо сообщать `CoreCompile` имена всех загруженных модулей, чтобы при
изменении этих файлов происходила перезагрузка.

В дальнейшем следует перенести логику чтения файлов в `CoreCompile`, а
реализация поддержки языков будет работать исключительно с содержимым файлов.

#### Проверка типов во время JIT компиляции и перезагрузки

Во время JIT-компиляции (как при первой компиляции, так и при перезагрузке) у
нас есть требуемый интерфейс модуля. С другой стороны, у нас есть интерфейс,
реализуемый модулем. Эти интерфейсы должны совпадать, и их можно проверить на
соответствие.

#### Поддрежка внешних модулей

